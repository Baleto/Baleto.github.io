<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <title>Mini Games â€” Fundamentals of HTTP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0d12" />
  <link rel="stylesheet" href="assets/css/style.css" />
  <style>
    :root{
      --panel:#0e1420; --bg:#0b0f17; --ink:#e6f1ff; --muted:#94a3b8;
      --brand:#60a5fa; --brand-ink:#051327; --border:#1e293b; --radius:12px; --maxw:960px;
    }
    body{ background:var(--bg); color:var(--ink); }
    .site-nav { position: sticky; top: 0; z-index: 50; background: var(--bg); border-bottom: 1px solid var(--border); }
    .site-nav .wrap { max-width: var(--maxw); margin: 0 auto; padding: 12px 24px; display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .brand { font-weight: 700; letter-spacing: .3px; }
    .nav-links { display: flex; gap: 18px; flex: 1 1 auto; flex-wrap: wrap; }
    .nav-links a { color: var(--brand); text-decoration: none; font-size: .95rem; padding: 6px 2px; border-bottom: 2px solid transparent; }
    .nav-links a:hover { border-bottom-color: var(--border); background: var(--brand); color: var(--brand-ink); border-radius: 8px; padding: 6px 8px; }
    header.page { padding: 16px 24px; display: flex; align-items: center; gap: 12px; border-bottom: 1px solid var(--border); background: var(--panel); border-top: 1px solid var(--border); }
    header.page h1 { margin: 0; font-size: 1.25rem; letter-spacing: .3px; }

    main.mg { max-width: var(--maxw); margin: 0 auto; padding: 20px 24px; }

    /* Action bar */
    .actionbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }
    .group { display:flex; gap:8px; flex-wrap:wrap; }
    .btn {
      display:inline-flex; align-items:center; gap:.45rem; padding:.6rem .9rem;
      border-radius:10px; border:1px solid #223047; background:#121a2a; color:var(--ink);
      cursor:pointer; box-shadow: 0 0 0 1px #0c1117 inset, 0 6px 18px rgba(0,0,0,.28);
      transition: transform .08s ease, box-shadow .2s ease, background .2s;
      user-select:none;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 0 0 1px #23314a inset, 0 10px 28px rgba(0,0,0,.36); background:#162238; }
    .btn:disabled { opacity:.55; cursor:not-allowed; transform:none; }
    .btn.brand { background:var(--brand); color:var(--brand-ink); border-color:transparent; }
    .btn.ghost { background:transparent; }

    .console-wrap { position:relative; }
    .console {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: radial-gradient(1200px 600px at 50% 30%, #10131a 0%, #0a0d12 60%, #070a0f 100%);
      border: 1px solid var(--border); border-radius: var(--radius);
      box-shadow: 0 0 0 1px #0c1117 inset, 0 8px 30px rgba(0,0,0,.35);
      padding: 12px; height: 420px; overflow: auto; white-space: pre-wrap; line-height: 1.45;
      color:#cfe8ff; text-shadow:0 1px 0 rgba(0,0,0,.3);
    }
    .console::before{
      content:""; position:absolute; inset:0;
      background: repeating-linear-gradient(to bottom, rgba(255,255,255,.035), rgba(255,255,255,.035) 1px, transparent 2px, transparent 3px);
      pointer-events:none; mix-blend-mode:overlay; opacity:.15; border-radius: var(--radius);
    }
    .console .caret{ display:inline-block; width:.6ch; height:1em; margin-left:2px; background:#9ad1ff; animation:blink 1s steps(1) infinite; }
    @keyframes blink{50%{opacity:0}}

    .io { display: flex; gap: 8px; margin-top: 10px; }
    .io input { flex: 1; padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border); background: var(--panel); color: var(--ink); }
    .hint { color: var(--muted); font-size: .9rem; margin-top: 8px; }

    /* Stats modal */
    .modal.hidden{ display:none }
    .modal{ position:fixed; inset:0; display:grid; place-items:center; background:rgba(5,8,12,.65); backdrop-filter: blur(3px); }
    .modal-card{ background:#0f1420; border:1px solid #1f2a3b; padding:18px 20px; border-radius:14px; width:min(620px,92vw); box-shadow:0 18px 36px rgba(0,0,0,.55) }
    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin:12px 0 }
    .stat{ background:#0b111a; border:1px solid #1c2535; padding:12px; border-radius:10px }
    .stat .n{ font-size:1.35rem; font-weight:700 }

    /* FX canvases */
    .fx-layer { position: fixed; inset: 0; pointer-events: none; }
  </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to main content</a>

  <header class="navbar site-nav" role="banner">
    <div class="wrap navbar-inner">
      <a href="index.html" class="brand">HTTP Fundamentals</a>
      <nav id="main-nav" aria-label="Main" class="nav-links">
        <a href="index.html">Home</a>
        <a href="concepts.html">Key Concepts</a>
        <a href="http-methods.html">HTTP Methods</a>
        <a href="status-codes.html">Status Codes</a>
        <a href="references.html">References</a>
        <a href="about.html">About</a>
        <a href="mini-games.html" aria-current="page">Mini Games</a>
      </nav>
      <button class="badge" aria-label="Toggle light/dark theme" onclick="toggleTheme?.()">ğŸŒ™ / â˜€ï¸ Theme</button>
    </div>
  </header>

  <header class="page">
    <h1>ğŸ•¹ï¸ Mini Games <span class="pill">Vanilla JS</span></h1>
  </header>

  <main id="main" class="mg">
    <div class="actionbar">
      <div class="group">
        <button class="btn" id="btn-gtn" title="Guess the Number">ğŸ¯ Guess the Number</button>
        <button class="btn" id="btn-over" title="Over/Under">â•â– Over/Under</button>
        <button class="btn" id="btn-rps" title="Rock/Paper/Scissors">âœŠâœ‹âœŒï¸ RPS</button>
        <button class="btn" id="btn-hang" title="Hangman">ğŸª¢ Hangman</button>
        <button class="btn" id="btn-bj" title="Blackjack Lite">ğŸ‚¡ Blackjack</button>
      </div>
      <div class="group" style="margin-left:auto">
        <button class="btn brand" id="btn-stats">ğŸ“Š Show Stats</button>
        <button class="btn ghost" id="btn-reset-stats">âŸ² Reset Stats</button>
        <a class="btn" href="index.html">ğŸ  Back to Home</a>
      </div>
    </div>

    <div class="console-wrap">
      <div class="console" id="console" aria-live="polite" aria-label="Arcade console output"></div>
    </div>

    <div class="io">
      <input id="stdin" type="text" placeholder="Type here and press Enter (or click Send)" aria-label="Game input" disabled />
      <button id="btn-send" class="btn" disabled>Send</button>
    </div>

    <p class="hint">Tip: select a game above. The console stays quiet until you choose one. No popupsâ€”ever. ğŸ™‚</p>
  </main>

  <!-- FX layers -->
  <canvas id="fx" class="fx-layer"></canvas>
  <canvas id="stars" class="fx-layer" style="z-index:-1"></canvas>

  <!-- Stats Modal -->
  <div id="statsModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
    <div class="modal-card">
      <h3 id="statsTitle">Your Stats</h3>
      <div id="statsGrid" class="grid"></div>
      <button class="btn ghost" id="closeStats">Close</button>
    </div>
  </div>

  <script>
  // =========================================================
  // 0) UTIL: Console / Input / Sounds / FX
  // =========================================================
  const $ = id => document.getElementById(id);
  const con = $("console");
  const stdin = $("stdin");
  const sendBtn = $("btn-send");

  let typewriter = true;     // set false for instant printing
  let caretOn = true;
  let inputEnabled = false;
  let pendingResolve = null;

  function stripCaret(){ const c = con.querySelector(".caret"); if(c) c.remove(); }
  function appendRaw(text=""){
    stripCaret();
    con.textContent += text;
    if (caretOn) con.insertAdjacentHTML("beforeend", '<span class="caret"></span>');
    con.scrollTop = con.scrollHeight;
  }
  async function printLine(line=""){
    if (!typewriter) { appendRaw(line+"\n"); return; }
    for (const ch of (line+"\n")) {
      appendRaw(ch);
      await sleep(ch===" "?0:9);
      sfx.type(); // soft key tick
    }
  }
  function clearConsole(){ con.textContent=""; }

  stdin.addEventListener("keydown", e => { if (e.key === "Enter") sendBtn.click(); });
  sendBtn.addEventListener("click", () => {
    if (!inputEnabled) return;
    const v = stdin.value.trim();
    if (!v) return;
    stdin.value = "";
    appendRaw(v+"\n");
    sfx.click();
    if (pendingResolve) { const r = pendingResolve; pendingResolve=null; r(v); }
  });

  function enableInput(flag){
    inputEnabled = flag;
    stdin.disabled = sendBtn.disabled = !flag;
    if (flag) stdin.focus();
  }

  function ask(prompt){
    return new Promise(async res=>{
      await printLine(prompt);
      pendingResolve = res;
    });
  }

  const sleep = ms => new Promise(r=>setTimeout(r,ms));

  // =========================================================
  // 1) PERSISTENCE: localStorage stats (Python-compatible keys)
  // =========================================================
  const STORAGE_KEY = "arcade.stats.v1";
  function defaultStats(){
    return {
      version:1,
      gtn_user_wins:0, gtn_cpu_wins:0, gtn_best_attempts:null, gtn_current_streak:0, gtn_best_streak:0,
      over_user_wins:0, over_cpu_wins:0, over_best_streak:0,
      rps_user_wins:0, rps_cpu_wins:0, rps_best_streak:0,
      hang_user_wins:0, hang_cpu_wins:0, hang_best_saves:0,
      bj_user_wins:0, bj_cpu_wins:0, bj_blackjacks:0, bj_best_streak:0,
    };
  }
  function loadStats(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return defaultStats();
      const obj = JSON.parse(raw);
      return {...defaultStats(), ...obj};
    }catch{return defaultStats();}
  }
  function saveStats(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(stats)); }
  function inc(k, n=1){ stats[k] = (stats[k]||0) + n; }
  function setmax(k, v){ const cur = stats[k]; if (cur==null || v>cur) stats[k]=v; }
  function setmin(k, v){ const cur = stats[k]; if (cur==null || v<cur) stats[k]=v; }

  let stats = loadStats();

  // =========================================================
  // 2) SOUNDS (WebAudio tiny beeps/jingles)
  // =========================================================
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const actx = new AudioCtx();
  const sfx = {
    beep(freq=440, dur=0.08, gain=0.04){
      const o = actx.createOscillator(), g = actx.createGain();
      o.frequency.value=freq; o.type="sine";
      g.gain.value=gain; o.connect(g); g.connect(actx.destination);
      o.start(); o.stop(actx.currentTime+dur);
    },
    type(){ if (document.hidden) return; this.beep(280,0.015,0.012); },
    click(){ this.beep(420,0.03,0.03); },
    bad(){ this.beep(160,0.14,0.06); },
    win(){
      // tiny 3-note arpeggio
      const seq=[660,880,990]; seq.forEach((f,i)=>setTimeout(()=>this.beep(f,0.09,0.05), i*90));
    }
  };

  // resume audio on first user gesture (mobile/desktop policy)
  ["pointerdown","keydown"].forEach(ev=>document.addEventListener(ev, ()=>actx.resume(), {once:true}));

  // =========================================================
  // 3) FX: Confetti & Starfield
  // =========================================================
  const fx = $("fx"), stars = $("stars");
  fx.width = stars.width = innerWidth; fx.height = stars.height = innerHeight;
  addEventListener("resize", ()=>{ fx.width = stars.width = innerWidth; fx.height = stars.height = innerHeight; });

  // Starfield
  (function starfield(){
    const ctx = stars.getContext("2d");
    const N = 140, pts = [];
    for(let i=0;i<N;i++) pts.push({x:Math.random()*stars.width, y:Math.random()*stars.height, s:Math.random()*2+0.4, v:Math.random()*0.2+0.05});
    function tick(){
      ctx.clearRect(0,0,stars.width,stars.height);
      ctx.fillStyle="#8ab4ff";
      for(const p of pts){
        p.y += p.v; if (p.y>stars.height) { p.y= -4; p.x=Math.random()*stars.width; }
        ctx.globalAlpha = 0.35 + 0.65*(p.s/2.4);
        ctx.fillRect(p.x,p.y,p.s,p.s);
      }
      requestAnimationFrame(tick);
    }
    tick();
  })();

  // Confetti
  function confettiBurst(cx=innerWidth/2, cy=innerHeight*0.35, count=42){
    const ctx = fx.getContext("2d");
    const bits = Array.from({length:count}, ()=>({
      x:cx, y:cy,
      vx:(Math.random()*2-1)*4, vy:-Math.random()*4-3,
      rot: Math.random()*6.28, vr:(Math.random()*0.2-0.1),
      life: 60+Math.random()*40, size: 6+Math.random()*6,
      color: `hsl(${Math.random()*360},85%,65%)`
    }));
    function step(){
      ctx.clearRect(0,0,fx.width,fx.height);
      bits.forEach(b=>{
        b.x+=b.vx; b.y+=b.vy; b.vy+=0.12; b.rot+=b.vr; b.life--;
        ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.rot);
        ctx.fillStyle=b.color; ctx.globalAlpha=Math.max(0, b.life/100);
        ctx.fillRect(-b.size/2,-b.size/2,b.size,b.size);
        ctx.restore();
      });
      if (bits.some(b=>b.life>0)) requestAnimationFrame(step); else ctx.clearRect(0,0,fx.width,fx.height);
    }
    step();
  }

  // =========================================================
  // 4) UI wiring (buttons / stats modal / reset confirmation)
  // =========================================================
  const btns = {
    gtn: $("btn-gtn"),
    over: $("btn-over"),
    rps: $("btn-rps"),
    hang: $("btn-hang"),
    bj: $("btn-bj"),
    stats: $("btn-stats"),
    resetStats: $("btn-reset-stats"),
  };

  const modal = $("statsModal"), statsGrid = $("statsGrid"), closeStats = $("closeStats");
  btns.stats.addEventListener("click", ()=>{ renderStatsGrid(); modal.classList.remove("hidden"); sfx.click(); });
  closeStats.addEventListener("click", ()=> modal.classList.add("hidden"));
  modal.addEventListener("click", e=>{ if (e.target===modal) modal.classList.add("hidden"); });

  btns.resetStats.addEventListener("click", async ()=>{
    sfx.bad();
    await printLine("âš ï¸  Reset all stats? Type YES to confirm (anything else cancels):");
    enableInput(true);
    const a = (await nextLine()).toUpperCase();
    if (a==="YES"){
      stats = defaultStats(); saveStats();
      await printLine("âœ… Stats reset.");
    } else {
      await printLine("Reset cancelled.");
    }
  });

  function renderStatsGrid(){
    const dash = (v)=> (v===null || v===undefined) ? "â€”" : v;
    statsGrid.innerHTML = `
      <div class="stat"><div>Guess the Number â€” You / CPU</div><div class="n">${stats.gtn_user_wins} / ${stats.gtn_cpu_wins}</div><div>Best Attempts: ${dash(stats.gtn_best_attempts)} â€¢ Best Streak: ${stats.gtn_best_streak}</div></div>
      <div class="stat"><div>Over/Under â€” You / CPU</div><div class="n">${stats.over_user_wins} / ${stats.over_cpu_wins}</div><div>Best Streak: ${stats.over_best_streak}</div></div>
      <div class="stat"><div>RPS â€” You / CPU</div><div class="n">${stats.rps_user_wins} / ${stats.rps_cpu_wins}</div><div>Best Streak: ${stats.rps_best_streak}</div></div>
      <div class="stat"><div>Hangman â€” You / CPU</div><div class="n">${stats.hang_user_wins} / ${stats.hang_cpu_wins}</div><div>Best Saves: ${stats.hang_best_saves}</div></div>
      <div class="stat"><div>Blackjack â€” You / CPU</div><div class="n">${stats.bj_user_wins} / ${stats.bj_cpu_wins}</div><div>Blackjacks: ${stats.bj_blackjacks} â€¢ Best Streak: ${stats.bj_best_streak}</div></div>
    `;
  }

  // =========================================================
  // 5) Input helpers
  // =========================================================
  function normalizeYN(s){ s=(s||"").trim().toUpperCase(); if(["Y","YES"].includes(s))return "Y"; if(["N","NO"].includes(s))return "N"; return null; }
  function normalizePick(s, allowed){ s=(s||"").trim().toUpperCase(); return allowed.includes(s) ? s : null; }
  function nextLine(){
    return new Promise(res=>{ pendingResolve = res; });
  }
  async function promptPick(question, allowed){
    let p=null;
    while(!p){
      enableInput(true);
      const ans = await ask(question);
      p = normalizePick(ans, allowed);
      if(!p){ sfx.bad(); await printLine(`Please enter one of: ${allowed.join("/")}`); }
    }
    return p;
  }
  async function promptInt(question, min, max, allowQuit=false){
    while(true){
      enableInput(true);
      const raw = await ask(question);
      if (allowQuit && raw.toLowerCase()==="quit") return "QUIT";
      const v = parseInt(raw,10);
      if(!Number.isNaN(v) && v>=min && v<=max) return v;
      sfx.bad(); await printLine(`Enter a whole number between ${min} and ${max}.`);
    }
  }
  async function promptChar(question, allow="abcdefghijklmnopqrstuvwxyz", allowQuit=false){
    while(true){
      enableInput(true);
      const raw = (await ask(question)).toLowerCase();
      if (allowQuit && raw==="quit") return "QUIT";
      if (raw.length===1 && allow.includes(raw)) return raw;
      sfx.bad(); await printLine(`Please enter a single letter Aâ€“Z.`);
    }
  }

  // =========================================================
  // 6) Games (vanilla JS)
  // =========================================================

  // 6A) Guess The Number
  async function gameGTN(){
    const start = {
      you: stats.gtn_user_wins, cpu: stats.gtn_cpu_wins,
      bestAtt: stats.gtn_best_attempts, bestStreak: stats.gtn_best_streak
    };
    clearConsole(); await printLine("ğŸ¯ Guess the Number");
    await printLine(`Start â€” You: ${start.you} | CPU: ${start.cpu} | Best Attempts: ${start.bestAtt??"â€”"} | Best Streak: ${start.bestStreak}`);

    const rangePick = await promptPick(
      "\nChoose range: A) 1â€“100  B) 2â€“50  C) 3â€“15  â†’",
      ["A","B","C"]
    );
    let lowest, highest, rangeLabel;
    if (rangePick==="A"){ lowest=1; highest=100; rangeLabel="1â€“100"; }
    else if (rangePick==="B"){ lowest=2; highest=50; rangeLabel="2â€“50"; }
    else { lowest=3; highest=15; rangeLabel="3â€“15"; }

    const diffPick = await promptPick(
      "Difficulty: A) Unlimited  B) 5 tries  C) 3 tries  D) 1 try  â†’",
      ["A","B","C","D"]
    );

    let attempts, Hot_Max, Cold_Max, diffName;
    if (diffPick==="A"){ attempts=Infinity; Hot_Max=6; Cold_Max=16; diffName="Easy"; }
    else if (diffPick==="B"){ attempts=5; Hot_Max=5; Cold_Max=15; diffName="Medium"; }
    else if (diffPick==="C"){ attempts=3; Hot_Max=4; Cold_Max=12; diffName="Hard"; }
    else { attempts=1; Hot_Max=3; Cold_Max=10; diffName="Impossible"; }

    const secret = Math.floor(Math.random()*(highest-lowest+1))+lowest;
    const tried = new Set(); let tries=0;

    await printLine(`\n*** GUESS THE NUMBER! *** [${rangeLabel} | ${diffName}]`);
    await printLine("Type a number (or 'quit' to leave).");

    while(tries<attempts){
      enableInput(true);
      const raw = await nextLine();
      if (raw.toLowerCase()==="quit"){
        const c = await promptPick("Quit? Y/N â†’ ", ["Y","N"]);
        if (c==="Y"){ await printLine("Okayâ€”back to menu."); return; }
        await printLine("Coolâ€”let's continue!");
        continue;
      }
      const n = parseInt(raw,10);
      if (Number.isNaN(n)){ sfx.bad(); await printLine("Please enter a valid integer."); continue; }
      if (n<lowest || n>highest){ sfx.bad(); await printLine(`Stay within ${lowest}..${highest}.`); continue; }
      if (tried.has(n)){ sfx.bad(); await printLine("Already triedâ€”pick another."); continue; }
      tried.add(n); tries++;

      const diff = Math.abs(secret-n);
      if (diff===0){
        await printLine(`ğŸ”¥ Hot potato! It was ${secret}. You got it in ${tries} ${tries===1?"try":"tries"}!`);
        inc("gtn_user_wins"); stats.gtn_current_streak++; setmax("gtn_best_streak", stats.gtn_current_streak);
        const prevBest = stats.gtn_best_attempts;
        setmin("gtn_best_attempts", tries);
        if (prevBest==null || tries < prevBest) await printLine("ğŸ… New personal record for fewest attempts!");
        if (tries===1) await printLine("ğŸ’¨ Achievement: Speed Demon (1 try!)");
        if (stats.gtn_current_streak>=3) await printLine(`ğŸ’¥ Streak: ${stats.gtn_current_streak} wins in a row!`);
        saveStats(); sfx.win(); confettiBurst();
        break;
      } else if (diff===1){ await printLine("You're ğŸ”¥ burning!"); }
        else if (diff<=Hot_Max){ await printLine("You're hot!"); }
        else if (diff<=Cold_Max){ await printLine("You're coldâ€”keep at it!"); }
        else { await printLine(n<secret? "Too low!" : "Too high!"); }
    }

    if (tries>=attempts && attempts!==Infinity){
      await printLine(`Out of attempts! The number was ${secret}.`);
      inc("gtn_cpu_wins"); stats.gtn_current_streak=0; saveStats(); sfx.bad();
    }

    await printLine(`\nEnd â€” You: ${stats.gtn_user_wins} | CPU: ${stats.gtn_cpu_wins} | Best Attempts: ${stats.gtn_best_attempts??"â€”"} | Best Streak: ${stats.gtn_best_streak}`);
  }

  // 6B) Over / Under
  async function gameOverUnder(){
    const start = { you:stats.over_user_wins, cpu:stats.over_cpu_wins, best:stats.over_best_streak };
    clearConsole(); await printLine("â•â– Over/Under");
    await printLine(`Start â€” You: ${start.you} | CPU: ${start.cpu} | Best Streak: ${start.best}`);

    const rPick = await promptPick("Rounds: A) 3  B) 2  C) 1  â†’", ["A","B","C"]);
    const rounds = rPick==="A"?3:rPick==="B"?2:1;
    const TARGET = 20;
    let sessionStreak = 0;

    for (let i=1;i<=rounds;i++){
      const original = rand(10,25);
      const addOpt = rand(1,6);
      const subOpt = rand(1,6);
      await printLine(`\nRound ${i}: start ${original}`);
      const choice = await promptPick(`1) Add ${addOpt}   2) Subtract ${subOpt} â†’`, ["1","2"]);
      const final = choice==="1" ? original+addOpt : original-subOpt;
      await printLine(`Final total: ${final}`);

      const origDiff = Math.abs(TARGET-original);
      const finalDiff = Math.abs(TARGET-final);

      if (finalDiff < origDiff){ await printLine("You win this round!"); inc("over_user_wins"); sessionStreak++; sfx.win(); }
      else if (finalDiff > origDiff){ await printLine("CPU wins this round!"); inc("over_cpu_wins"); sessionStreak=0; sfx.bad(); }
      else { await printLine("Tie on closeness â€” CPU takes it."); inc("over_cpu_wins"); sessionStreak=0; sfx.bad(); }

      setmax("over_best_streak", sessionStreak); saveStats();
    }
    if (sessionStreak>=2) await printLine(`ğŸ¯ Hot Streak: ${sessionStreak} in a row!`); 
    await printLine(`\nEnd â€” You: ${stats.over_user_wins} | CPU: ${stats.over_cpu_wins} | Best Streak: ${stats.over_best_streak}`);
  }

  // 6C) Rock / Paper / Scissors
  async function gameRPS(){
    const start = { you:stats.rps_user_wins, cpu:stats.rps_cpu_wins, best:stats.rps_best_streak };
    clearConsole(); await printLine("âœŠâœ‹âœŒï¸ Rock, Paper, Scissors");
    await printLine(`Start â€” You: ${start.you} | CPU: ${start.cpu} | Best Streak: ${start.best}`);

    const mPick = await promptPick("Mode: A) Single  B) Best of 3  C) Best of 5 â†’", ["A","B","C"]);
    const roundsToWin = mPick==="A"?1:mPick==="B"?2:3;
    const totalRounds = mPick==="A"?1:mPick==="B"?3:5;
    const name = mPick==="A"?"Single Round":mPick==="B"?"Best of 3":"Best of 5";

    await printLine(`\n*** ${name} *** (R/P/S) â€” type 'quit' to leave.`);

    const valid = {R:"Rock", P:"Paper", S:"Scissors"};
    const beats = {R:"S", P:"R", S:"P"};
    let u=0, c=0, streak=0;

    while(true){
      const mv = await promptRPS("Your move (R/P/S): ");
      if (mv==="QUIT"){ await printLine("Returningâ€¦"); saveStats(); return; }
      const cpu = ["R","P","S"][rand(0,2)];
      await printLine(`You chose ${valid[mv]}; CPU chose ${valid[cpu]}.`);

      if (mv===cpu){ await printLine("Draw."); }
      else if (beats[mv]===cpu){ await printLine("You win the round!"); u++; streak++; sfx.win(); }
      else { await printLine("CPU wins the round!"); c++; streak=0; sfx.bad(); }

      if (totalRounds===1){
        if (u>c){ await printLine("You won the match!"); inc("rps_user_wins"); setmax("rps_best_streak", streak); saveStats(); confettiBurst(); }
        else if (c>u){ await printLine("CPU won the match!"); inc("rps_cpu_wins"); saveStats(); }
        else await printLine("Match draw.");
        break;
      } else {
        if (u===roundsToWin){
          await printLine("You won the match!"); inc("rps_user_wins"); setmax("rps_best_streak", streak); saveStats(); confettiBurst();
          if (mPick==="B" && u===2 && c===0) await printLine("ğŸ… Flawless 2â€“0!");
          if (mPick==="C" && u===3 && c===0) await printLine("ğŸ… Flawless 3â€“0!");
          break;
        }
        if (c===roundsToWin){ await printLine("CPU won the match!"); inc("rps_cpu_wins"); saveStats(); break; }
      }
    }
    await printLine(`\nEnd â€” You: ${stats.rps_user_wins} | CPU: ${stats.rps_cpu_wins} | Best Streak: ${stats.rps_best_streak}`);
  }

  async function promptRPS(q){
    while(true){
      enableInput(true);
      const raw = (await ask(q)).trim().toUpperCase();
      if (raw==="QUIT") return "QUIT";
      if (["R","P","S"].includes(raw)) return raw;
      sfx.bad(); await printLine("Enter R, P, or S.");
    }
  }

  // 6D) Hangman
  async function gameHangman(){
    const start = { you:stats.hang_user_wins, cpu:stats.hang_cpu_wins, best:stats.hang_best_saves };
    clearConsole(); await printLine("ğŸª¢ Hangman");
    await printLine(`Start â€” You: ${start.you} | CPU: ${start.cpu} | Best Saves: ${start.best}`);

    const dPick = await promptPick("Difficulty: A) 8 wrong  B) 6 wrong  C) 4 wrong â†’", ["A","B","C"]);
    const wrongLimit = dPick==="A"?8:dPick==="B"?6:4;
    const WORDS = ["python","variable","function","module","package","iterator","condition","boolean","integer","float","string","tuple","list","dictionary","hangman","random","persist","stats","arcade","program"];
    const secret = WORDS[rand(0, WORDS.length-1)];
    const guessed = new Set(), correct = new Set(), wrong = new Set();
    let wrongLeft = wrongLimit;

    await printLine("\nGuess letters Aâ€“Z. Type 'quit' to exit.");
    await renderMask();

    while(true){
      const ch = await promptChar("Letter: ", "abcdefghijklmnopqrstuvwxyz", true);
      if (ch==="QUIT"){ await printLine("Leaving gameâ€¦"); saveStats(); return; }
      if (guessed.has(ch)){ sfx.bad(); await printLine("Already guessed."); continue; }
      guessed.add(ch);

      if (secret.includes(ch)){ correct.add(ch); await printLine("Correct!"); sfx.click(); }
      else { wrong.add(ch); wrongLeft--; await printLine("Incorrect!"); sfx.bad(); }

      await renderMask();
      if ([...secret].every(ch=>correct.has(ch))){
        await printLine(`You win! The word was: ${secret.toUpperCase()}`);
        inc("hang_user_wins"); setmax("hang_best_saves", wrongLeft); saveStats(); confettiBurst(); sfx.win();
        if (wrongLeft===wrongLimit) await printLine("ğŸ… Flawless Victory â€” no wrong guesses!");
        break;
      }
      if (wrongLeft<=0){
        await printLine(`Out of guesses! The word was: ${secret.toUpperCase()}`);
        inc("hang_cpu_wins"); saveStats(); break;
      }
    }

    await printLine(`\nEnd â€” You: ${stats.hang_user_wins} | CPU: ${stats.hang_cpu_wins} | Best Saves: ${stats.hang_best_saves}`);

    async function renderMask(){
      const mask = [...secret].map(ch=> correct.has(ch)? ch.toUpperCase() : "_").join(" ");
      await printLine(`Word: ${mask}`);
      await printLine(`Wrong left: ${wrongLeft}${wrong.size? " | Wrong: "+[...wrong].join(", ").toUpperCase():""}`);
    }
  }

  // 6E) Blackjack Lite (simple best-of logic, hits to 17)
  async function gameBJ(){
    const start = {
      you:stats.bj_user_wins, cpu:stats.bj_cpu_wins, blackjacks:stats.bj_blackjacks, best:stats.bj_best_streak
    };
    clearConsole(); await printLine("ğŸ‚¡ Blackjack Lite");
    await printLine(`Start â€” You: ${start.you} | CPU: ${start.cpu} | Naturals: ${start.blackjacks} | Best Streak: ${start.best}`);

    const m = await promptPick("Mode: A) Single  B) Best of 3  C) Best of 5 â†’", ["A","B","C"]);
    const roundsToWin = m==="A"?1:m==="B"?2:3;
    const totalRounds = m==="A"?1:m==="B"?3:5;

    let userRounds=0, cpuRounds=0, sessionStreak=0;

    while(true){
      const deck = buildDeck();
      const player=[deck.pop(),deck.pop()], dealer=[deck.pop(),deck.pop()];
      let pt=handTotal(player), dt=handTotal(dealer);

      await printLine("\nDealingâ€¦");
      await printLine(`You: ${handStr(player)} (total ${pt})`);
      await printLine(`Dealer: [hidden], ${cardStr(dealer[1])}`);

      let roundOver=false;

      if (pt===21 && dt===21){ await printLine("Both Blackjack! Push."); roundOver=true; }
      else if (pt===21){ await printLine("Blackjack! You win!"); inc("bj_user_wins"); inc("bj_blackjacks"); userRounds++; sessionStreak++; roundOver=true; confettiBurst(); sfx.win(); }
      else if (dt===21){ await printLine("Dealer Blackjack. CPU wins."); inc("bj_cpu_wins"); cpuRounds++; sessionStreak=0; roundOver=true; sfx.bad(); }

      while(!roundOver){
        const mv = await promptPick("Hit or Stand? (H/S) â†’", ["H","S","QUIT"]);
        if (mv==="QUIT"){ await printLine("Leavingâ€¦"); saveStats(); return; }
        if (mv==="H"){
          player.push(deck.pop()); pt=handTotal(player);
          await printLine(`You draw: ${cardStr(player[player.length-1])} â†’ ${pt}`);
          if (pt>21){ await printLine("Bust! CPU wins."); inc("bj_cpu_wins"); cpuRounds++; sessionStreak=0; roundOver=true; sfx.bad(); }
          continue;
        }
        // Stand
        await printLine(`You stand at ${pt}. Dealer reveals: ${handStr(dealer)} (total ${dt})`);
        while(dt<17){ const c=deck.pop(); dealer.push(c); dt=handTotal(dealer); await printLine(`Dealer draws: ${cardStr(c)} â†’ ${dt}`); }
        if (dt>21){ await printLine("Dealer busts! You win."); inc("bj_user_wins"); userRounds++; sessionStreak++; confettiBurst(); sfx.win(); }
        else if (pt>dt){ await printLine("You win the round!"); inc("bj_user_wins"); userRounds++; sessionStreak++; sfx.win(); }
        else if (pt<dt){ await printLine("CPU wins the round!"); inc("bj_cpu_wins"); cpuRounds++; sessionStreak=0; sfx.bad(); }
        else { await printLine("Push."); }
        roundOver=true;
      }

      setmax("bj_best_streak", sessionStreak); saveStats();

      if (totalRounds===1) break;
      if (userRounds===roundsToWin){
        await printLine("You won the match!");
        if (m==="B" && userRounds===2 && cpuRounds===0) await printLine("ğŸ… Flawless 2â€“0!");
        if (m==="C" && userRounds===3 && cpuRounds===0) await printLine("ğŸ… Flawless 3â€“0!");
        break;
      }
      if (cpuRounds===roundsToWin){ await printLine("CPU won the match!"); break; }
    }

    await printLine(`\nEnd â€” You: ${stats.bj_user_wins} | CPU: ${stats.bj_cpu_wins} | Naturals: ${stats.bj_blackjacks} | Best Streak: ${stats.bj_best_streak}`);

    // helpers
    function buildDeck(){
      const ranks=["A","2","3","4","5","6","7","8","9","10","J","Q","K"], suits=["â™ ","â™¥","â™¦","â™£"];
      const d=[]; for(const r of ranks) for(const s of suits) d.push([r,s]); shuffle(d); return d;
    }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    function cardStr([r,s]){ return `${r}${s}`; }
    function handStr(h){ return h.map(cardStr).join(", "); }
    function handTotal(h){
      let t=0, aces=0;
      for(const [r] of h){
        if (["J","Q","K"].includes(r)) t+=10;
        else if (r==="A"){ t+=11; aces++; }
        else t+=parseInt(r,10);
      }
      while(t>21 && aces>0){ t-=10; aces--; }
      return t;
    }
  }

  // =========================================================
  // 7) Launchers
  // =========================================================
  btns.gtn.addEventListener("click", ()=>runSafely(gameGTN));
  btns.over.addEventListener("click", ()=>runSafely(gameOverUnder));
  btns.rps.addEventListener("click", ()=>runSafely(gameRPS));
  btns.hang.addEventListener("click", ()=>runSafely(gameHangman));
  btns.bj.addEventListener("click", ()=>runSafely(gameBJ));

  async function runSafely(fn){
    // The console stays empty until a game is chosen â€“ now we run.
    /// (We also ensure input piping is enabled for the game session.)
    try{
      caretOn = true;
      enableInput(false);
      await fn();
      await printLine("\n[Session ended]");
      enableInput(false);
    }catch(e){
      await printLine("\n[Error] " + e.message);
    }
  }

  // =========================================================
  // 8) Helpers
  // =========================================================
  function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  </script>

  <!-- Theme initializer (site-wide) -->
  <script defer src="./assets/theme.js"></script>
</body>
</html>
